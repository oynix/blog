<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>&lt;Effective Java&gt;读书整理 | Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="书地址 ：链接: https://pan.baidu.com/s/1kUAwYgv 密码: ij4j">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="&lt;Effective Java&gt;读书整理">
<meta property="og:url" content="http://yoursite.com/2017/11/07/『Effective Java』读书整理/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="书地址 ：链接: https://pan.baidu.com/s/1kUAwYgv 密码: ij4j">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-12-03T00:32:56.089Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="&lt;Effective Java&gt;读书整理">
<meta name="twitter:description" content="书地址 ：链接: https://pan.baidu.com/s/1kUAwYgv 密码: ij4j">
  
    <link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Oynix</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-『Effective Java』读书整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/07/『Effective Java』读书整理/" class="article-date">
  <time datetime="2017-11-07T08:33:53.000Z" itemprop="datePublished">2017-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      &lt;Effective Java&gt;读书整理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>书地址 ：链接: <a href="https://pan.baidu.com/s/1kUAwYgv" target="_blank" rel="noopener">https://pan.baidu.com/s/1kUAwYgv</a> 密码: ij4j<br><a id="more"></a></p>
<h3 id="Chapter-3-适用于所有对象"><a href="#Chapter-3-适用于所有对象" class="headerlink" title="- Chapter 3 适用于所有对象"></a>- Chapter 3 适用于所有对象</h3><h4 id="8-重写equals方法"><a href="#8-重写equals方法" class="headerlink" title="8. 重写equals方法"></a><strong>8. 重写<code>equals</code>方法</strong></h4><blockquote>
<p>三个原则：对称性、传递性、一致性</p>
</blockquote>
<h4 id="9-重写equals方法必定要重写hashCode方法"><a href="#9-重写equals方法必定要重写hashCode方法" class="headerlink" title="9. 重写equals方法必定要重写hashCode方法"></a><strong>9. 重写<code>equals</code>方法必定要重写<code>hashCode</code>方法</strong></h4><blockquote>
<p>例如在HashMap中存储时会调用该方法</p>
</blockquote>
<h4 id="10-始终要重写toString方法"><a href="#10-始终要重写toString方法" class="headerlink" title="10. 始终要重写toString方法"></a><strong>10. 始终要重写<code>toString</code>方法</strong></h4><blockquote>
<p>便于阅读，使类用起来更加舒适</p>
</blockquote>
<h4 id="11-谨慎的覆盖clone方法"><a href="#11-谨慎的覆盖clone方法" class="headerlink" title="11. 谨慎的覆盖clone方法"></a><strong>11. 谨慎的覆盖<code>clone</code>方法</strong></h4><blockquote>
<p>相当于另一个构造器</p>
</blockquote>
<h4 id="12-考虑实现Comparable接口"><a href="#12-考虑实现Comparable接口" class="headerlink" title="12. 考虑实现Comparable接口"></a><strong>12. 考虑实现Comparable接口</strong></h4><blockquote>
<p>用于对象比较、排序（在集合里sort）</p>
</blockquote>
<hr>
<h3 id="Chapter-4-类和接口"><a href="#Chapter-4-类和接口" class="headerlink" title="- Chapter 4 类和接口"></a>- Chapter 4 类和接口</h3><h4 id="13-使类和成员的可访问性最小化-encapsulation"><a href="#13-使类和成员的可访问性最小化-encapsulation" class="headerlink" title="13. 使类和成员的可访问性最小化(encapsulation)"></a><strong>13. 使类和成员的可访问性最小化(encapsulation)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误方式,安全漏洞; </span></span><br><span class="line"><span class="comment">// 当域为基本类型或不可变对象时安全;</span></span><br><span class="line"><span class="comment">// 当为可变对象的引用时存在安全漏洞, VALUE虽不可修改但数组里的对象可被修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUE = &#123;....&#125;;</span><br><span class="line"><span class="comment">// 正确方式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123;...&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br></pre></td></tr></table></figure>
<h4 id="14-在公有类中使用访问方法而非公有域"><a href="#14-在公有类中使用访问方法而非公有域" class="headerlink" title="14. 在公有类中使用访问方法而非公有域"></a><strong>14. 在公有类中使用访问方法而非公有域</strong></h4><blockquote>
<p>总有类永远不应该暴露可变域</p>
</blockquote>
<h4 id="15-使可变性最小化"><a href="#15-使可变性最小化" class="headerlink" title="15. 使可变性最小化"></a><strong>15. 使可变性最小化</strong></h4><p>成为不可变类的5条规则 :</p>
<ol>
<li>不要提供任何会修改对象状态的方法;</li>
<li>保证类不会被扩展(fina);</li>
<li>使所有域都是final的;</li>
<li>使所有域都成为私有的;</li>
<li>确保对于任何可变组件的互斥访问.</li>
</ol>
<h4 id="16-复合优先于继承"><a href="#16-复合优先于继承" class="headerlink" title="16. 复合优先于继承"></a><strong>16. 复合优先于继承</strong></h4><blockquote>
<p>当B和A的关系为”is-a”时，让B继承自A；否则B中应包含一个A的实例（复合），而不是扩展A（继承）。</p>
</blockquote>
<h4 id="17-要么为继承而设计，并提供文档说明，-要么就禁止继承"><a href="#17-要么为继承而设计，并提供文档说明，-要么就禁止继承" class="headerlink" title="17. 要么为继承而设计，并提供文档说明， 要么就禁止继承"></a><strong>17. 要么为继承而设计，并提供文档说明， 要么就禁止继承</strong></h4><blockquote>
<p>1&gt;. 关于程序文档有句格言：<em>好的API文档应该描述一个给定的方法做了什么工作，而不是描述它如何做到的。</em></p>
</blockquote>
<p>为了允许继承，类还必须遵守其他一些约束：</p>
<ul>
<li>构造器决不能调用可被覆盖的方法；</li>
<li>无论是clone（Cloneable接口）还是readObject（Serializable接口），都不可调用可覆盖的方法，不管是直接还是间接的方式。</li>
</ul>
<h4 id="18-接口优先于抽象类"><a href="#18-接口优先于抽象类" class="headerlink" title="18. 接口优先于抽象类"></a><strong>18. 接口优先于抽象类</strong></h4><blockquote>
<p>抽象类的演变比接口容易；<br>骨架实现，即接口的简单实现</p>
</blockquote>
<h4 id="19-接口只用于定义类型"><a href="#19-接口只用于定义类型" class="headerlink" title="19. 接口只用于定义类型"></a><strong>19. 接口只用于定义类型</strong></h4><blockquote>
<p>避免常量接口；<br>接口应该只被用来定义类型</p>
</blockquote>
<h4 id="20-类层次优先于标签类"><a href="#20-类层次优先于标签类" class="headerlink" title="20. 类层次优先于标签类"></a><strong>20. 类层次优先于标签类</strong></h4><blockquote>
<p>标签类过于冗长、容易出错，并且效率底下</p>
</blockquote>
<h4 id="21-用函数对象表示策略"><a href="#21-用函数对象表示策略" class="headerlink" title="21. 用函数对象表示策略"></a><strong>21. 用函数对象表示策略</strong></h4><blockquote>
<p>比较器：String.CASE_INSENSITIVE_ORDER</p>
</blockquote>
<h4 id="22-优先考虑静态成员类"><a href="#22-优先考虑静态成员类" class="headerlink" title="22. 优先考虑静态成员类"></a><strong>22. 优先考虑静态成员类</strong></h4><p>嵌套类种类</p>
<ol>
<li>静态成员类；</li>
<li>非静态成员类；</li>
<li>匿名类；</li>
<li>局部类。</li>
</ol>
<p>后三种都被称为内部类。</p>
<blockquote>
<p>如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使它成为静态成员类，而不是非静态成员类。如果省略了static修饰符，则每个实例都将包含一个额外的指向外围对象的引用。例如ViewHolder。</p>
</blockquote>
<hr>
<h3 id="Chapter-5-泛型"><a href="#Chapter-5-泛型" class="headerlink" title="- Chapter 5 泛型"></a>- Chapter 5 泛型</h3><h4 id="23-请不要在新代码中使用原生态类型"><a href="#23-请不要在新代码中使用原生态类型" class="headerlink" title="23. 请不要在新代码中使用原生态类型"></a>23. 请不要在新代码中使用原生态类型</h4><ul>
<li><code>Set</code> : 原生态类型， 脱离了泛型系统；</li>
<li><code>Set&lt;?&gt;</code> : 无限通配符类型，只能包含某种未知对象类型；</li>
<li><code>Set&lt;Object&gt;</code>: 参数化类型，可以包含任何对象类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Set) &#123;</span><br><span class="line">	Set&lt;?&gt; m = (Set&lt;?&gt;) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>术语</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数化类型</td>
<td><code>List&lt;String&gt;</code></td>
</tr>
<tr>
<td>实际类型参数</td>
<td><code>String</code></td>
</tr>
<tr>
<td>泛型</td>
<td><code>List&lt;E&gt;</code></td>
</tr>
<tr>
<td>形式类型参数</td>
<td><code>E</code></td>
</tr>
<tr>
<td>无限制通配符类型</td>
<td><code>List&lt;?&gt;</code></td>
</tr>
<tr>
<td>有限制类型参数</td>
<td><code>&lt;E extends Number&gt;</code></td>
</tr>
<tr>
<td>递归类型限制</td>
<td><code>&lt;T extends Comparable&lt;T&gt;&gt;</code></td>
</tr>
<tr>
<td>有限制通配符类型</td>
<td><code>List&lt;? extends Number&gt;</code></td>
</tr>
<tr>
<td>泛型方法</td>
<td><code>static &lt;E&gt;List&lt;E&gt; asList(E[] a)</code></td>
</tr>
<tr>
<td>泛型令牌</td>
<td><code>String.class</code></td>
</tr>
</tbody>
</table>
<h4 id="24-消除非受检警告"><a href="#24-消除非受检警告" class="headerlink" title="24. 消除非受检警告"></a><strong>24. 消除非受检警告</strong></h4><blockquote>
<p>@SuppressWarnings(“unchecked”)要放在一个声明上，要将禁止非受检警告范围缩到最小；每次使用时都要添加一个注释，说明为什么这么做是安全的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如ArrayList中的toArray方法, 注解不加在方法上而是单独声明一个局部变量</span></span><br><span class="line"><span class="comment">// 为的就是缩小非受检警告范围, 这么做是值得的.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">	<span class="keyword">if</span> (a.length &lt; size) &#123;</span><br><span class="line">		<span class="comment">// This cast is correct because the array we're creating </span></span><br><span class="line">		<span class="comment">// is of the same type as the one passed in, which is T[].</span></span><br><span class="line">		<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">		T[] result = (T[]) Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	System.arrayCopy(elements, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">	<span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">		a[size] = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="25-列表优先于数组"><a href="#25-列表优先于数组" class="headerlink" title="25. 列表优先于数组"></a><strong>25. 列表优先于数组</strong></h4><ul>
<li>禁止创建泛型数组，优先使用集合；</li>
<li>数组是协变且可以具体化的，泛型是不可变的且可以被擦除的。</li>
<li>混合使用时如何得到编译时错误或者警告时，用列表代替数组。</li>
</ul>
<h4 id="26-优先考虑泛型"><a href="#26-优先考虑泛型" class="headerlink" title="26. 优先考虑泛型"></a><strong>26. 优先考虑泛型</strong></h4><blockquote>
<p>使用泛型比使用需要在客户端代码中进行转换的类型来的更加安全，也更加容易。只要时间允许，就把现有的类型都泛型化。</p>
</blockquote>
<h4 id="27-优先考虑泛型方法"><a href="#27-优先考虑泛型方法" class="headerlink" title="27. 优先考虑泛型方法"></a><strong>27. 优先考虑泛型方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归泛型 类型参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">	Iterator&lt;T&gt; i = list.iterator();</span><br><span class="line">	T result = i.next();</span><br><span class="line">	<span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">		T t = i.next();</span><br><span class="line">		<span class="keyword">if</span> (t.compare(result) &gt; <span class="number">0</span>)</span><br><span class="line">			result = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="28-利用有限制通配符来提升API的灵活性"><a href="#28-利用有限制通配符来提升API的灵活性" class="headerlink" title="28. 利用有限制通配符来提升API的灵活性"></a><strong>28. 利用有限制通配符来提升API的灵活性</strong></h4><blockquote>
<p>为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。<br><strong>PECS表示producer-extends，consumer-super</strong><br>换句话说， 如果参数化类型表示一个T生产者，就使用&lt;? extends T&gt;；如果表示一个T消费者，就使用&lt;? super T&gt;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Stack示例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;? extends E&gt; src)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (E e : src)</span><br><span class="line">		push(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!isEmpty()) </span><br><span class="line">		dst.add(pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改过的使用通配符类型的声明：PECS规则，list生产T实例，T的comparable消费T实例并产生表示顺序关系的整值。comparable始终是消费者，因此使用时始终应该是<code>Comparable&lt;? super T&gt;</code>优先于<code>Comparable&lt;T&gt;</code>。对于comparator也一样，因此使用时始终应该是<code>Comparator&lt;? super T&gt;</code> 优先于<code>Comparator&lt;T&gt;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(List&lt;? extends T&gt; list)</span>  </span>&#123;</span><br><span class="line">	<span class="comment">// 这里做了修改</span></span><br><span class="line">	Iterator&lt;? extends T&gt; i = list.iterator();</span><br><span class="line">	T result = i.next();</span><br><span class="line">	<span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">		T t = i.next();</span><br><span class="line">		<span class="keyword">if</span> (t.compare(result) &gt; <span class="number">0</span>)</span><br><span class="line">			result = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="29-优先考虑类型安全的异构容器"><a href="#29-优先考虑类型安全的异构容器" class="headerlink" title="29. 优先考虑类型安全的异构容器"></a><strong>29. 优先考虑类型安全的异构容器</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (type == <span class="keyword">null</span>) </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"type is null"</span>);</span><br><span class="line">		favorites.put(type, instance);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确保永远不违背它的类型约束条件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.checkedXXX();</span><br></pre></td></tr></table></figure></p>
<p>利用Class.asSubclass方法进行转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Annotation&gt; <span class="function">T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationType)</span></span>;</span><br><span class="line">Class&lt;?&gt; typeOne = Class.forName(typeOneInstance);</span><br><span class="line">getAnnotation(typeOne.asSubclass(Annotation.class));</span><br></pre></td></tr></table></figure>
<h3 id="Chapter-6-枚举和注解"><a href="#Chapter-6-枚举和注解" class="headerlink" title="-Chapter 6 枚举和注解"></a>-Chapter 6 枚举和注解</h3><h4 id="30-用enum代替int常量"><a href="#30-用enum代替int常量" class="headerlink" title="30. 用enum代替int常量"></a><strong>30. 用enum代替int常量</strong></h4><blockquote>
<p>枚举类型有一个自动产生valueOf（String）方法，它将常量的名字转变成常量本身；<br>枚举中的switch语句适合于给外部的枚举类型增加特定于常量的行为。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">	PLUS(<span class="string">"+"</span>) &#123;<span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x + y;&#125; &#125;,</span><br><span class="line">	MIMUS(<span class="string">"-"</span>) &#123;<span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x - y&#125; &#125;,</span><br><span class="line">	TIMES(<span class="string">"*"</span>) &#123;<span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x * y&#125; &#125;,</span><br><span class="line">	DIVEDES(<span class="string">"/"</span>) &#123;<span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x / y&#125; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String symbol;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Operation</span><span class="params">(String sym)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.symbol = sym;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> symbol;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="31-用实例域代替序数"><a href="#31-用实例域代替序数" class="headerlink" title="31. 用实例域代替序数"></a><strong>31. 用实例域代替序数</strong></h4><blockquote>
<p>所有的枚举都有一个<code>ordinal</code>方法， 它返回每个枚举常量在类型中的数字位置。永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</span><br><span class="line">	SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> numberOfMusicians;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Ensemble</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.numberOfMusicians = size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusician</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> numberOfMusicians;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="32-用EnumSet代替位域"><a href="#32-用EnumSet代替位域" class="headerlink" title="32. 用EnumSet代替位域"></a><strong>32. 用EnumSet代替位域</strong></h4><blockquote>
<p>正是因为枚举类型要用在集合Set中, 所有没有理由用位域来表示它.EnumSet具有简洁和性能的优势.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> Style &#123;BOLD, ITALIC, UNDERLINE, STRIKETHROUGH&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 所有的Set都可传入, 但是EnumSet最好</span></span><br><span class="line">	<span class="comment">// 考虑到可能还有其他实现,所以使用Set&lt;Style&gt;而不是EnumSet&lt;Style&gt;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(Set&lt;Style&gt; styles)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是将EnumSet实例传递给applyStyles方法的客户端代码。EnumSet提供了丰富的</span></span><br><span class="line"><span class="comment">// 静态工厂来轻松创建集合, 其中一个如下</span></span><br><span class="line">text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="33-用EnumMap代替序数索引"><a href="#33-用EnumMap代替序数索引" class="headerlink" title="33. 用EnumMap代替序数索引"></a><strong>33. 用EnumMap代替序数索引</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Herb.Type, Set&lt;Herb&gt;&gt; herbsByType = <span class="keyword">new</span> EnumMap&lt;Herb.Type, Set&lt;Herb&gt;&gt;(Herb.Type.class);</span><br><span class="line"><span class="keyword">for</span> (Herb.Type t : Herb.Type.values()) &#123;</span><br><span class="line">	herbsByType.put(t, <span class="keyword">new</span> HashSet&lt;Herb&gt;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Herb b : garden) &#123;</span><br><span class="line">	herbsByType.get(b.type).add(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="34-用接口模拟可伸缩的枚举"><a href="#34-用接口模拟可伸缩的枚举" class="headerlink" title="34. 用接口模拟可伸缩的枚举"></a><strong>34. 用接口模拟可伸缩的枚举</strong></h4><blockquote>
<p>避免扩展枚举类型(继承), 采用用枚举类型实现接口(实现)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">// ExtendOperation实现了这个接口</span></span><br><span class="line"><span class="keyword">public</span> ExtendOperation implements Operation&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x = <span class="number">3.3</span>;</span><br><span class="line">	<span class="keyword">double</span> y = <span class="number">3.4</span>;</span><br><span class="line">	<span class="comment">// 方法一</span></span><br><span class="line">	test(ExtendOperation.class, x, y);</span><br><span class="line">	<span class="comment">// 方法二</span></span><br><span class="line">	test(Arrays.asList(ExtendOperation.values()), x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法一 : 确保Class对象既表示枚举又表示Operation的子类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt; &amp; Operation&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	Class&lt;T&gt; opSet, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Operation op : opSet.getEnumConstants()) &#123;</span><br><span class="line">		<span class="comment">// do sth</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Collection&lt;? extends Operation&gt; opSet, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Operation op : opSet) &#123;</span><br><span class="line">		<span class="comment">// do sth</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="35-注解优先于命名模式"><a href="#35-注解优先于命名模式" class="headerlink" title="35. 注解优先于命名模式"></a><strong>35. 注解优先于命名模式</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解类, 只用在无参数的静态方法上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">Class testClass = Class.forName(agrs[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (Method m : testClass.getDeclaredMethods()) &#123;</span><br><span class="line">	<span class="comment">// 判断某个方法是否被Test注解标注</span></span><br><span class="line">	<span class="keyword">if</span> (m.isAnnotationPresent(Test.class)) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 可直接执行说明是静态方法; 传入null说明无参数</span></span><br><span class="line">			m.invoke(<span class="keyword">null</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span>(InvocationTargetException ite) &#123;</span><br><span class="line">			<span class="comment">// 1. 实例方法</span></span><br><span class="line">			<span class="comment">// 2. 一个或多个参数</span></span><br><span class="line">			<span class="comment">// 3. 不可访问的方法</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有抛出异常才算成功的注解类</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionTest &#123;</span><br><span class="line">	Class&lt;? extends Exception&gt; value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 待测试的方法</span></span><br><span class="line"><span class="meta">@ExceptionTest</span>(ArithmeticException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	i = i / i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ExceptionTest</span>(ArithmeticException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> i = arr[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ExceptionTest</span>(ArithmeticException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试工具类</span></span><br><span class="line"><span class="keyword">if</span> (m.isAnnotationPresent(ExceptionTest.class)) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		m.invoke(<span class="keyword">null</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InvocationTargetExcetpion ite) &#123;</span><br><span class="line">		<span class="comment">// 出现的异常类型</span></span><br><span class="line">		Throwable exception = ite.getCause();</span><br><span class="line">		<span class="comment">// 期待的异常类型</span></span><br><span class="line">		Class&lt;? extends Exception&gt; ex = m.getAnnotation(ExceptionTest.class).value();</span><br><span class="line">		<span class="comment">// 出现的异常与期待的异常时同一种</span></span><br><span class="line">		<span class="keyword">if</span> (ex.instanceOf(exception)) &#123;...&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多种类型异常注解类</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementTarget.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExceptionsTest &#123;</span><br><span class="line">	Class&lt;? extends Exception&gt;[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 待测试方法注解</span></span><br><span class="line"><span class="meta">@ExceptionsTest</span>(&#123;IndexOutOfBoundException.class, ArithmeticException.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="36-坚持使用Override注解"><a href="#36-坚持使用Override注解" class="headerlink" title="36. 坚持使用Override注解"></a><strong>36. 坚持使用Override注解</strong></h4><blockquote>
<p>IDE可检查</p>
</blockquote>
<h4 id="37-用标记接口定义类型"><a href="#37-用标记接口定义类型" class="headerlink" title="37. 用标记接口定义类型"></a><strong>37. 用标记接口定义类型</strong></h4><p><strong>标记接口，类似于Serializable接口，没有方法，只是一个空接口作为标记，被标记过的实例可以通过ObjectOutputStream处理。</strong><br>两者比较：标记接口和标记注解</p>
<ul>
<li>标记接口定义的类型是由被标记类的实例实现的；标记注解则是没有定义这样的类型。这个类型允许你在编译时捕捉在使用标记注解的情况下要到运行时才能捕捉到的错误；</li>
<li>标记接口的另一个优点，可以被跟家精确的锁定；</li>
<li>标记注解胜过标记接口的最大优点在于，它可以通过默认的方式添加一个或者多个注解类型元素，给一倍使用过的注解类型添加更多的信息。随着时间的推移，简单类型的标记注解可以演变成丰富的标记注解， 标记接口则不能。</li>
<li>标记注解的另一个优点在于，它们是更大的注解机制的一部分。因此，标记注解在那些支持注解作为编程元素之一的框架中同样具有一致性。</li>
</ul>
<p>区分使用</p>
<ul>
<li>应用到任何程序元素（方法，字段等）而不是类或者接口，必须用标记注解；</li>
<li>标记类和接口， 优先使用标记接口；</li>
<li>标记只用于特殊接口的元素，将标记定义为该接口的一个子接口；</li>
<li>如果以后需要扩展，用标记注解；</li>
<li>当目标是ElementType.TYPE时，多考虑标记接口。</li>
</ul>
<h3 id="Chapter-7-方法"><a href="#Chapter-7-方法" class="headerlink" title="-Chapter 7 方法"></a>-Chapter 7 方法</h3><h4 id="38-检查参数的有效性"><a href="#38-检查参数的有效性" class="headerlink" title="38. 检查参数的有效性"></a><strong>38. 检查参数的有效性</strong></h4><ul>
<li>在方法体的开头检查参数；</li>
<li>使用断言assert，失败时抛出AssertionError；</li>
<li>检查构造器的参数尤为重要</li>
</ul>
<h4 id="39-必要时进行保护性拷贝"><a href="#39-必要时进行保护性拷贝" class="headerlink" title="39. 必要时进行保护性拷贝"></a><strong>39. 必要时进行保护性拷贝</strong></h4><ul>
<li>保护性拷贝是在检查参数有效性之前进行的，并且有效性检查是针对拷贝之后的对象；</li>
<li>对于参数类型可以被不可信任方子类化的参数，请不要使用clone进行保护性拷贝</li>
</ul>
<h4 id="40-谨慎设计方法签名"><a href="#40-谨慎设计方法签名" class="headerlink" title="40. 谨慎设计方法签名"></a><strong>40. 谨慎设计方法签名</strong></h4><ol>
<li>谨慎选择方法名称。</li>
<li>不要过于追求提供便利的方法。</li>
<li>避免过长的参数列表（小于等于4）。</li>
<li>对于参数类型，优先使用接口而不是类。</li>
<li>对于boolean参数， 优先使用两个元素的枚举类型。</li>
</ol>
<h4 id="41-慎用重载"><a href="#41-慎用重载" class="headerlink" title="41. 慎用重载"></a><strong>41. 慎用重载</strong></h4><ul>
<li>对于重载方法（overloaded method）的选择是静态的，而对于被覆盖的方法（overridden method）的选择是动态的。</li>
<li>避免胡乱使用重载机制的安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法是可变参数，保守策略是根本不要重载它。</li>
</ul>
<h4 id="42-慎用可变参数"><a href="#42-慎用可变参数" class="headerlink" title="42. 慎用可变参数"></a><strong>42. 慎用可变参数</strong></h4><h4 id="43-返回零长度的数组或集合，而不是null"><a href="#43-返回零长度的数组或集合，而不是null" class="headerlink" title="43. 返回零长度的数组或集合，而不是null"></a><strong>43. 返回零长度的数组或集合，而不是null</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Cheese&gt; cheeseInStock = ....;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Cheese[] EMPTY_CHEESE_ARRAY = <span class="keyword">new</span> Cheese[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Cheese[] getCheese() &#123;</span><br><span class="line">	<span class="keyword">return</span> cheeseInStock.toArray(EMPTY_CHEESE_ARRAY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合值的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheeseList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cheeseOfStock .isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Cheese&gt;(cheeseOfStock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="44-为所有到处的API元素编写文档注释"><a href="#44-为所有到处的API元素编写文档注释" class="headerlink" title="44. 为所有到处的API元素编写文档注释"></a><strong>44. 为所有到处的API元素编写文档注释</strong></h4><h3 id="Chapter-8-通用程序设计"><a href="#Chapter-8-通用程序设计" class="headerlink" title="-Chapter 8 通用程序设计"></a>-Chapter 8 通用程序设计</h3><h4 id="45-将局部变量的作用域最小化"><a href="#45-将局部变量的作用域最小化" class="headerlink" title="45. 将局部变量的作用域最小化"></a><strong>45. 将局部变量的作用域最小化</strong></h4><ul>
<li>要是局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。</li>
<li>几乎每个局部变量的声明都应该包含一个初始化表达式，如果没有则应推迟声明。try-catch例外。</li>
<li>如果循环终止之后不再需要循环变量的内容，for循环优于while循环。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n的作用是:避免每次循环产生额外计算的开销</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> , n = getSize(); i &lt; n; i++) &#123;</span><br><span class="line">	doSomething(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="46-for-each循环优于传统的for循环"><a href="#46-for-each循环优于传统的for循环" class="headerlink" title="46. for-each循环优于传统的for循环"></a><strong>46. for-each循环优于传统的for循环</strong></h4><p>三种情况无法使用for-each</p>
<ol>
<li>过滤：如果需要遍历集合，并删除选定的元素，就需要使用显示的迭代器，以便可以调用它的remove方法。</li>
<li>转换：如果需要遍历列表或者数组，并取代它的部分或者全部元素值，就需要列表迭代器或者数组索引，以便设定元素的值。</li>
<li>平行迭代：如果需要并行的遍历多个集合，就需要显示的控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以得到同步前移。</li>
</ol>
<h4 id="47-了解和使用类库"><a href="#47-了解和使用类库" class="headerlink" title="47. 了解和使用类库"></a><strong>47. 了解和使用类库</strong></h4><ul>
<li>使用标准类库而不是专门的实现。</li>
<li>Collections Framework</li>
<li>java.util.concurrent包含高级并发工具来简化多线程的编程任务，还包含低级别的并发基本类型</li>
</ul>
<h4 id="48-如果需要精确的答案，-请避免使用float和double"><a href="#48-如果需要精确的答案，-请避免使用float和double" class="headerlink" title="48. 如果需要精确的答案， 请避免使用float和double"></a><strong>48. 如果需要精确的答案， 请避免使用float和double</strong></h4><blockquote>
<p>使用int或者long或者BigDecimal替代。</p>
</blockquote>
<h4 id="49-基本类型优先于装箱基本类型"><a href="#49-基本类型优先于装箱基本类型" class="headerlink" title="49. 基本类型优先于装箱基本类型"></a><strong>49. 基本类型优先于装箱基本类型</strong></h4><h4 id="50-如果其他类型更适合，-则尽量避免使用字符串"><a href="#50-如果其他类型更适合，-则尽量避免使用字符串" class="headerlink" title="50. 如果其他类型更适合， 则尽量避免使用字符串"></a><strong>50. 如果其他类型更适合， 则尽量避免使用字符串</strong></h4><ul>
<li>字符串不合适代替其他的值类型。</li>
<li>字符串不合适代替枚举类型。</li>
<li>字符串不适合代替聚集类型。</li>
<li>字符串也不适合代替能力表。</li>
</ul>
<h4 id="51-当心字符串连接的性能"><a href="#51-当心字符串连接的性能" class="headerlink" title="51. 当心字符串连接的性能"></a><strong>51. 当心字符串连接的性能</strong></h4><blockquote>
<p>使用StringBuilder</p>
</blockquote>
<h4 id="52-通过接口引用对象"><a href="#52-通过接口引用对象" class="headerlink" title="52. 通过接口引用对象"></a><strong>52. 通过接口引用对象</strong></h4><blockquote>
<p>如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明，如List。<br>如果没哟合适的接口存在，完全可以用类而不是接口来引用对象，如值类String、BigInteger</p>
</blockquote>
<h4 id="53-接口优先于反射机制"><a href="#53-接口优先于反射机制" class="headerlink" title="53. 接口优先于反射机制"></a><strong>53. 接口优先于反射机制</strong></h4><h4 id="54-谨慎地使用本地方法"><a href="#54-谨慎地使用本地方法" class="headerlink" title="54. 谨慎地使用本地方法"></a><strong>54. 谨慎地使用本地方法</strong></h4><blockquote>
<p>使用本地方法提高性能的做法不值得提倡</p>
</blockquote>
<h4 id="55-谨慎地进行优化"><a href="#55-谨慎地进行优化" class="headerlink" title="55. 谨慎地进行优化"></a><strong>55. 谨慎地进行优化</strong></h4><ul>
<li>努力避免那些限制性能的设计决策。</li>
<li>为获得更好的性能而对API进行包装，这是一种非常不好的想法。</li>
</ul>
<h4 id="56-遵守普遍接受的命名惯例"><a href="#56-遵守普遍接受的命名惯例" class="headerlink" title="56. 遵守普遍接受的命名惯例"></a><strong>56. 遵守普遍接受的命名惯例</strong></h4><h3 id="Chapter-9-异常"><a href="#Chapter-9-异常" class="headerlink" title="-Chapter 9 异常"></a>-Chapter 9 异常</h3><h4 id="57-只针对异常的情况才使用异常"><a href="#57-只针对异常的情况才使用异常" class="headerlink" title="57. 只针对异常的情况才使用异常"></a><strong>57. 只针对异常的情况才使用异常</strong></h4><h4 id="58-对于可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#58-对于可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="58. 对于可恢复的情况使用受检异常，对编程错误使用运行时异常"></a><strong>58. 对于可恢复的情况使用受检异常，对编程错误使用运行时异常</strong></h4><h4 id="59-避免不必要地使用受检异常"><a href="#59-避免不必要地使用受检异常" class="headerlink" title="59. 避免不必要地使用受检异常"></a><strong>59. 避免不必要地使用受检异常</strong></h4><h4 id="60-优先使用标准的异常"><a href="#60-优先使用标准的异常" class="headerlink" title="60. 优先使用标准的异常"></a><strong>60. 优先使用标准的异常</strong></h4><h4 id="61-抛出与抽象相对应的异常"><a href="#61-抛出与抽象相对应的异常" class="headerlink" title="61. 抛出与抽象相对应的异常"></a><strong>61. 抛出与抽象相对应的异常</strong></h4><blockquote>
<p>底层的异常被传到高层的异常，高层的异常提供访问方法（Throwable.getCause）来获得底层的异常</p>
</blockquote>
<h4 id="62-每个方法抛出的异常都要有文档"><a href="#62-每个方法抛出的异常都要有文档" class="headerlink" title="62. 每个方法抛出的异常都要有文档"></a><strong>62. 每个方法抛出的异常都要有文档</strong></h4><h4 id="63-在细节消息中包含能捕获失败的信息"><a href="#63-在细节消息中包含能捕获失败的信息" class="headerlink" title="63. 在细节消息中包含能捕获失败的信息"></a><strong>63. 在细节消息中包含能捕获失败的信息</strong></h4><h4 id="64-努力使失败保持原子性"><a href="#64-努力使失败保持原子性" class="headerlink" title="64. 努力使失败保持原子性"></a><strong>64. 努力使失败保持原子性</strong></h4><h4 id="65-不要忽略异常"><a href="#65-不要忽略异常" class="headerlink" title="65. 不要忽略异常"></a><strong>65. 不要忽略异常</strong></h4><h3 id="Chapter-10-并发"><a href="#Chapter-10-并发" class="headerlink" title="-Chapter 10 并发"></a>-Chapter 10 并发</h3><h4 id="66-同步访问共享的可变数据"><a href="#66-同步访问共享的可变数据" class="headerlink" title="66. 同步访问共享的可变数据"></a><strong>66. 同步访问共享的可变数据</strong></h4><blockquote>
<p>当多个线程共享可变数据的时候，每个读或者写数据的线程必须执行同步。</p>
</blockquote>
<h4 id="67-避免过度同步"><a href="#67-避免过度同步" class="headerlink" title="67. 避免过度同步"></a><strong>67. 避免过度同步</strong></h4><ul>
<li>为了避免活性失败和安全性失败，在一个被同步的方法或者代码块中，永远不要放弃对客户端的控制。</li>
<li>在同步区域内做尽可能少的工作。</li>
<li>为了避免死锁和数据损坏，千万不要从同步区域内部调用外来方法。</li>
</ul>
<h4 id="68-executor和task优先于线程"><a href="#68-executor和task优先于线程" class="headerlink" title="68. executor和task优先于线程"></a><strong>68. executor和task优先于线程</strong></h4><h4 id="69-并发工具优先于wait和notify"><a href="#69-并发工具优先于wait和notify" class="headerlink" title="69. 并发工具优先于wait和notify"></a><strong>69. 并发工具优先于wait和notify</strong></h4><ul>
<li>除非迫不得已，否则应该优先使用ConcurrentHashMap，而不是使用Collections.synchronizedMap或Hashtable。只要用并发Map替代老式的同步Map，就可以极大地提升应用程序的性能。更一般地，应该优先使用并发集合，而不是使用外部的同步集合。</li>
<li>对于间歇式的定时，始终应该优先使用System.nanoTime，而不是System.currentTimeMills，前者更加准确也更加精确，它不受系统的实时始终的调整影响。</li>
<li>使用应该使用wait循环模式来调用wait方法；永远不要在循环之外调用wait方法。循环会在等待之前和之后测试条件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, String&gt; map = ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">intern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	String result = map.get(s);</span><br><span class="line">	<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 应对并发情况</span></span><br><span class="line">		result = map.putIfAbsent(s, s);</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">			result = s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="70-线程安全性的文档化"><a href="#70-线程安全性的文档化" class="headerlink" title="70. 线程安全性的文档化"></a><strong>70. 线程安全性的文档化</strong></h4><ul>
<li>“出现synchronized关键字就足以用文档说明线程安全性”的这种说法隐含了一个错误的观念，即认为线程安全性是一种“要么全有要么全无”的属性。</li>
</ul>
<p>线程安全性的几种级别：</p>
<ol>
<li>不可变的（immutable）：这个类的实例是不变的。所以，不需要外部的同步。这样的例子包括String、Long和BigInteger。</li>
<li>无条件的线程安全（unconditionally thread-safe）：这个类的实例是可变的，但是这个类有着足够的内部同步，所以，它的实例可以被并发使用，无需任何外部同步。其例子包括Random和ConcurrentHashMap。</li>
<li>有条件的线程安全（conditionally thread-safe）：除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件的线程安全相同。这样的例子包括Collections.synchronized包装返回的集合，它们的迭代器（iterator）要求外部同步。</li>
<li>非线程安全（not thread-safe）：这个类的实例是可变的。为了并发地使用它们，客户必须利用自己选择的外部同步包围每个方法调用（或者调用序列）。这样的例子包括通用的集合实现，例如ArrayList和HashMap。</li>
<li>线程对立的（thread-hostile）：这个类不能安全地被多个线程并发使用，即使所有的方法调用都被外部同步包围。线程对立的根源通常在于，没有同步地修改静态数据。没有人会有意编写一个线程对立的类；这种类是因为没有考虑到并发性儿产生的后果。幸运的是，在Java平台类库中，线程对立的类或者方法非常少。System.runFinalizersOnExit方法是线程对立的，但已经被废除了。</li>
</ol>
<h4 id="71-慎用延迟初始化"><a href="#71-慎用延迟初始化" class="headerlink" title="71. 慎用延迟初始化"></a><strong>71. 慎用延迟初始化</strong></h4><ul>
<li>在大多数情况下，正常初始化要优先于延迟初始化。如果域只在类的实例部分被访问，并且初始化这个域的开销很高，可能就值得进行延迟初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟初始化，要使用同步访问方法</span></span><br><span class="line"><span class="keyword">private</span> FieldType field;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (field == <span class="keyword">null</span>)</span><br><span class="line">		field = computeFieldValue();</span><br><span class="line">	<span class="keyword">return</span> field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果出于性能的考虑而需要对<strong>静态域</strong>使用延迟初始化，就是用lazy initialization holder class模式。这种模式保证了类要到用到的时候才会被初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Field <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> FieldHolder.field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果处于性能考虑而需要对<strong>实例域</strong>使用延迟初始化，就使用双重检查模式。这种模式避免了在域被初始化之后访问这个域时的锁定开销。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"><span class="function">FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 局部变量result的作用是确保field只在已经被初始化的情况下读取一次,提升性能</span></span><br><span class="line">	FieldType result = field;</span><br><span class="line">	<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">			result = field;</span><br><span class="line">			<span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">				field = result = computeFieldValue();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>延迟初始化一个可以接受重复初始化的实例域，可使用单重检查模式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FieldType result = field;</span><br><span class="line">	<span class="keyword">if</span> (result == <span class="keyword">null</span>) </span><br><span class="line">		field = result = computeFieldValue();</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="72-不要依赖于线程调度器"><a href="#72-不要依赖于线程调度器" class="headerlink" title="72. 不要依赖于线程调度器"></a><strong>72. 不要依赖于线程调度器</strong></h4><blockquote>
<p>不要让程序的正确性依赖于线程调度器，否则结果得到的应用将既不健壮也不具有可移植性。作为推论，不要依赖Thread.yield或者线程优先级。</p>
</blockquote>
<h4 id="73-避免使用线程组"><a href="#73-避免使用线程组" class="headerlink" title="73. 避免使用线程组"></a><strong>73. 避免使用线程组</strong></h4><h3 id="Chapter-11-序列化"><a href="#Chapter-11-序列化" class="headerlink" title="-Chapter 11 序列化"></a>-Chapter 11 序列化</h3><h4 id="74-谨慎地实现Serializable接口"><a href="#74-谨慎地实现Serializable接口" class="headerlink" title="74. 谨慎地实现Serializable接口"></a><strong>74. 谨慎地实现Serializable接口</strong></h4><blockquote>
<p>为了继承而设计的类应该尽可能少地去实现Serializable接口，用户的接口也应该尽可能少地继承Serializable接口。<br>如果一个类或者一个接口存在的目的主要是为了参与到某个框架中，该框架要求所有的参与者必须实现Serializable接口，这个时候实现或者扩展Serializable接口就很有意义。<br>内部类不应该实现Serializable，内部类的默认序列化形式是定义不清楚的，然而静态成员类却可以实现Serializable。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">AbstractFoo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">		s.defaultReadObject();</span><br><span class="line">		<span class="comment">// Manually deserialize and initialize superclass state</span></span><br><span class="line">		<span class="keyword">int</span> x = s.readInt();</span><br><span class="line">		<span class="keyword">int</span> y = s.readInt();</span><br><span class="line">		initialize(x, y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		s.defaultWriteObject();</span><br><span class="line">		<span class="comment">// Manually serialize superclass state</span></span><br><span class="line">		s.writeInt(getX());</span><br><span class="line">		s.writeInt(getY());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">185683560954L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="75-考虑使用自动以序列化形式"><a href="#75-考虑使用自动以序列化形式" class="headerlink" title="75. 考虑使用自动以序列化形式"></a><strong>75. 考虑使用自动以序列化形式</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> Entry head = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">		String data;</span><br><span class="line">		Entry next;</span><br><span class="line">		Entry previous;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个对象的物理表示法与它的逻辑数据内容有实质性的区别时，使用默认序列化形式会有以下4个缺点：</p>
<ol>
<li><strong>它使这个类的导出API永远地束缚在该类的内部表示法上。</strong>在上面的例子中，私有的StringList.Entry类变成了公有API的一部分。如果在将来额版本中，内部表示法发生了变化，StringList类仍将需要接受链表形式的输入，并产生链表形式的输出。这个类永远也摆脱不了维护链表项所需要的所有代码，即使它不再使用链表作为内部结构了，也仍然需要这些代码。</li>
<li><strong>它会消耗过多的空间。</strong>在上面的例子中，序列化形式既表示了链表中的每个项，也表示了所有的链接关系，这是不必要的。这些链表项以及链表只不过是实现细节，不值得记录在序列化形式中。因为这样的序列化形式过于庞大，所以把它写到硬盘中，或者在网络上发送都将非常慢。</li>
<li><strong>它会消耗过多的时间。</strong>序列化逻辑并不了解对象图的拓补关系，所以它必须要经过一个昂贵的图遍历（traversal）过程。在上面的例子中，沿着next引用进行遍历是非常简单的。</li>
<li><strong>它会引起栈溢出。</strong>默认的序列化过程要对对象图执行一次递归遍历，即使对于中等规模的对象图，这样的操作也可能引起栈溢出。到底多少个元素会引发栈溢出，这要取决于JVM的具体实现以及Java启动时的命令行参数，（比如Heap Size的-Xms与-Xmx的值）有些实现可能根本不存在这样的问题。</li>
</ol>
<p>修订版本，transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> Entry head = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">		String data;</span><br><span class="line">		Entry next;</span><br><span class="line">		Entry previous;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 添加指定的string到这个集合</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重写writeObject方法, 与物理表示法的细节脱离</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		s.defaultWriteObject();</span><br><span class="line">		s.writeInt(size);</span><br><span class="line">		<span class="keyword">for</span> (Entry e = head; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">			s.writeObject(e.data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重写readObject方法,与write对应</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">		s.defaultReadObject();</span><br><span class="line">		<span class="keyword">int</span> numElements = s.readInt();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i++) &#123;</span><br><span class="line">			add((String) s.readObject());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...<span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>尽管StringList的所有域都是瞬时的(transient)，但wirteObject方法的首要任务仍是调用defaultWriteObject，readObject方法的首要任务则是调用defaultReadObject。如果所有的实例域都是瞬时的，从技术角度而言，不调用defaultWriteObject和defaultReadObject也是允许的，但是不推荐这样做。即使所有的实例域都是transient的，调用defaultWriteObject也会影响该类的序列化形式，从而极大地增强灵活性。这样得到的序列化形式允许在以后的发行版中增加非transient实例域，并且还能保持向前或者向后兼容性。如果某一个实例将在未来的版本中被序列化，然后在前一个版本中被反序列化，那么，后增加的域将被忽略掉。如果旧版本的readObject方法没有调用defaultReadObject，反序列化过程将失败，引发StreamCorrupted Exception异常。<br>无论是否使用默认的序列化形式，当defaultWriteObject方法被调用的时候，每一个未被标记为transient的实例域都会被序列化。因此每一个可以被标记为transient的实例域都应该做上这样的标记。这包括那些冗余的域，即它们的值可以根据其他“基本数据类型”计算而得到的域，比如缓存起来的散列值。<strong>在将一个域做成非transient的之前，请一定要确信它的值是该对象逻辑状态的一部分。</strong>如果你正在使用一种自定义的序列化形式，大多数实例域，或者所有的实例域则都应该被标记为transient，就像上面例子中的StringList那样。<br>如果正在使用默认的序列化形式， 并且把一个或者多个域标记为transient，则要记住，当一个实例被反序列化的时候，这些域将被初始化为它们的默认值。<br>无论是否使用默认的序列化形式，如果在读取整个对象状态的任何其他方法上强制任何同步，则必须在对象序列化上强制这种同步。<br>不管选择了哪种序列化形式，都要为自己编写的每个可序列化的类声明一个显示的序列化版本UID（serial version UID）。第一避免不兼容，第二减小额外计算的开销。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pirvate <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = randomLongValue;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在编写新类时，为randomLongValue选择什么值并不重要。通过在该类上运行serialver工具，就可以得到这样一个值，但是，凭空编造一个数值也是可以的。如果想修改一个没有序列版本UID的现有的类，并希望新的版本能够接受现有的序列化实例，就必须使用serialver工具为旧版本生成值。</p>
</blockquote>
<h4 id="76-保护性地编写readObject方法"><a href="#76-保护性地编写readObject方法" class="headerlink" title="76. 保护性地编写readObject方法"></a><strong>76. 保护性地编写readObject方法</strong></h4><blockquote>
<p>当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，就必须要做保护性拷贝，这是非常重要的。</p>
</blockquote>
<p>指导方针：</p>
<ul>
<li>对于对象引用域必须保持为私有的类，要保护性的拷贝这些域中的每个对象。不可变类的可变组件就属于这一类别。</li>
<li>对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。</li>
<li>如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectInputValidation接口。</li>
<li>无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。</li>
</ul>
<h4 id="77-对于实例控制，枚举类型优先于readResolve"><a href="#77-对于实例控制，枚举类型优先于readResolve" class="headerlink" title="77. 对于实例控制，枚举类型优先于readResolve"></a><strong>77. 对于实例控制，枚举类型优先于readResolve</strong></h4><blockquote>
<p>readResolve特性允许你用readObject创建的实例代替另一个实例。对于一个正在被反序列化的对象，如果它的类定义了一个readResolve方法，并且具备正确的声明，那么在反序列化之后，新建对象上的readResolve方法就会被调用。然后该方法返回的对象引用将被返回，取代新建的对象。在这个特性的绝大多数用法中，指向新建对象的引用不需要再被保留，因此立即成为垃圾回收的对象。</p>
<p>总而言之，应该尽可能地使用枚举dang来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控的类，就必须提供一个readResolve方法，并确保该类的所有实例域都为基本类型，或者时transient。</p>
</blockquote>
<h4 id="78-考虑用序列化代理代替序列化实例"><a href="#78-考虑用序列化代理代替序列化实例" class="headerlink" title="78. 考虑用序列化代理代替序列化实例"></a><strong>78. 考虑用序列化代理代替序列化实例</strong></h4><p>序列化代理模式相当简单：</p>
<ol>
<li><p>为可序列化的类设计一个私有的静态嵌套类，精确地表示外围类的实例的逻辑状态。这个嵌套类被称作序列化代理，它应该有一个单独的构造器，其参数类型就是那个外围类。这个构造器只从它的参数中复制数据：它不需要进行任何一致性检查或者保护性拷贝。从设计的角度来看，序列化代理的默认序列化形式是外围类最好的序列化形式。外围类及其序列代理都必须声明实现Serializable接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static class SerializationProxy implements Serializable &#123;</span><br><span class="line">	private final Date start;</span><br><span class="line">	private final Date end;</span><br><span class="line"></span><br><span class="line">	SerializationProxy(Period p) &#123;</span><br><span class="line">		this.start = p.start;</span><br><span class="line">		this.end = p.end;</span><br><span class="line">	&#125;</span><br><span class="line">	private static final long serialVerionUID = 302480420480234L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，将下面的writeReplace方法添加到外围类中。通过序列化代理，这个方法可以被逐字复制到任何类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Object writeReplace() &#123;</span><br><span class="line">	return new SerializationProxy(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个方法的存在导致序列化系统产生一个SerializationProxy实例,代替外围类的实例。换句话说，writeReplace方法在序列化之前，将外围类的实例转变成了它的序列化代理。所以序列化系统永远不会产生外围类的序列化实例，为了避免攻击者伪造，只要在外围类中添加这个readObject方法即可：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(ObjectInputStream s) throws InvalidationException &#123;</span><br><span class="line">	throw new InvalidationException(&quot;Proxy required&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>最后，在SerializationProxy类中提供一个readResolve方法，它返回一个逻辑上相当于外围类的实例。这个方法使序列化系统在反序列化时将序列化代理转变回外围类的实例。<br>这个readResolve方法仅仅利用它的公有API创建外围类的一个实例，这正是该模式的魅力之所在。它极大地消除了序列化机制中语言本身之外的特征，因为反序列化实例是利用与任何其他实例相同的构造器、静态工厂和方法而创建的。这样就不必单独确保被反序列化的实例一定要遵守类的约束条件。如果该类的静态工厂或者构造器建立了这些约束条件，并且它的实例方法在维持着这些约束条件，你就可以确信序列化也会维持这些约束条件。<br>上述Period.SerializationProxy的readResolve方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Object readResolve() &#123;</span><br><span class="line">	return new Period(start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<ul>
<li>两个局限性：它不能与可以被客户端扩展的类兼容，它也不能与对象图中包含循环的某些类兼容：如果企图从一个对象的序列化代理的readResolve方法内部调用这个对象的方法，就会得到一个ClassCastException异常，因为还没有这个对象，只有它的序列化代理。</li>
<li>代价：比保护性拷贝进行的开销大。</li>
<li>当必须在一个不能被客户端扩展的类（final）上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/07/『Effective Java』读书整理/" data-id="cjaq3m381000514cm6hwlq5q0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/20/Windows下编译OpenSSL/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Windows下编译OpenSSL
        
      </div>
    </a>
  
  
    <a href="/2017/10/26/Android YuvImage直接旋转/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android YuvImage直接旋转</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenSSL/">OpenSSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RecyclerView/">RecyclerView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SlidingUpPanelLayout/">SlidingUpPanelLayout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yuv/">Yuv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jCenter/">jCenter</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/OpenSSL/" style="font-size: 10px;">OpenSSL</a> <a href="/tags/RecyclerView/" style="font-size: 10px;">RecyclerView</a> <a href="/tags/SlidingUpPanelLayout/" style="font-size: 10px;">SlidingUpPanelLayout</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/Yuv/" style="font-size: 10px;">Yuv</a> <a href="/tags/jCenter/" style="font-size: 10px;">jCenter</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/20/Windows下编译OpenSSL/">Windows下编译OpenSSL</a>
          </li>
        
          <li>
            <a href="/2017/11/07/『Effective Java』读书整理/">&lt;Effective Java&gt;读书整理</a>
          </li>
        
          <li>
            <a href="/2017/10/26/Android YuvImage直接旋转/">Android YuvImage直接旋转</a>
          </li>
        
          <li>
            <a href="/2017/10/24/ScrollView在SlidingUpPanelLayout中下滑无效问题/">ScrollView在SlidingUpPanelLayout中下滑无效问题</a>
          </li>
        
          <li>
            <a href="/2017/10/12/手把手教你实现RecyclerView的下拉刷新和上拉加载更多/">手把手教你实现RecyclerView的下拉刷新和上拉加载更多</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Oynix<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>